---
layout: post
title: Malloc 함수의 동작
---

> 개요
>
> MallocInternals 번역
>
> 

# 개요
 본 글은 [1]의 번역을 통해 malloc 함수의 동작을 살펴본다.
 
# MallocInternals 번역
## Malloc의 개요
 GNU C Library (glibc의) 의 malloc 라이브러리는 어플리케이션의 주소 공간에
할당된 메모리를 관리하는 다양한 함수들을 포함한다. Glibc malloc은
ptmalloc (pthreads malloc) 으로부터 파생되었고, ptmalloc은
dlmalloc (Doug Lea malloc) 으로부터 파생되었다. 이 malloc은 "힙 (heap)"
스타일을 따르고, 그것은 큰 영역의 메모리에 다양한 크기의 청크 (chunks) 가
존재한다는 것을 의미한다. 그리고 이는 예를 들자면, 비트맵과 배열 또는 동일한
크기의 블록 등을 사용하는 구현과 반대이다. 과거에는, 한 어플리케이션마다 하나의
힙만 할당되었지만, glibc의 malloc은 한 어플리케이션에 다수의 힙들이 할당되는
것을 허용한다. 이때 할당된 각각의 힙은 그 주소 공간 내부에서 자라게 된다.

 그럼, 이 문서에서 사용되는 몇 가지 용어를 정의해보자.
* Arena: 하나 또는 그 이상의 스레드가 공유하는, 하나 또는 그 이상의 힙 또는
힙 내부에서 "free"된 청크들의 링크드 리스트를 참조하는 구조체이다. 각 아레나에
연결된 스레드들은 그 아레나의 free 리스트로부터 메모리를 할당받을 것이다.
* Heap: 할당될 청크들로 나누어진 연속적인 영역의 메모리이다. 각 힙은 정확히
하나의 아레나에 속한다.
* Chunk: 할당될 수 있는(어플리케이션이 소유하는) 작은 범위의 메모리로, free될
수 있고 (이때는 glibc가 소유한다), 인접한 청크들과 결합되어 더 큰 범위를 가질
수 있다. 청크는 어플리케이션에게 할당되는 메모리의 블록을 둘러싸는 랩퍼 (wrapper)
라는 것을 기억하자. 각 청크는 하나의 힙에 존재하고 하나의 아레나에 속한다.
* Memory: 일반적으로 램 또는 스왑에 의해 얻어지는 어플리케이션 주소 공간의
비율을 말한다.

 본 문서에서 "메모리 (memory)"라는 용어를 오직 일반적인 용법으로만 사용할
것이다. 한편 glibc malloc 코드에는 리눅스 커널 (또는 다른 OS) 과 작업하는
코드가 있다. 그 코드는 커널에게 어떤 메모리가 매핑되어야 하는지와 어떤 메모리가
커널에게 리턴될 수 있는지에 대한 힌트를 주기 위한 것이다. 이때 "실제 메모리
(real memory)"와 "가상 메모리 (virtual memory)"의 구분은 명시되지 않는
한, 여기서 논하고자 하는 것과 관련이 없다.

## Chunk는 무엇인가?
 Glibc의 malloc은 chunk-oriented이다. 이는 큰 영역의 메모리 ("힙") 를
다양한 크기의 청크로 나눈다. 각 청크는 자신의 크기 (청크 헤더의 size 필드로)
와 인접한 청크들을 메타 데이터로 포함한다. 청크가 어플리케이션에 의해 사용될
때, "저장되는 데이터"는 청크의 크기뿐이다. 청크가 free되면, 어플리케이션의
데이터로 사용되던 부분은 아레나와 관련된 데이터로 채워지도록 재지정된다.
여기서 아레나와 관련된 데이터는 적합한 청크가 빠르게 검색되고, 필요하다면
재사용될 수 있도록, 링크드 리스트에서 사용되는 포인터와 같은 것이다. 또한,
free된 청크의 마지막 워드는 청크 크기가 복사된 것이다 (이때 LSB로부터
세 비트들을 0으로 둘 수도 있고, 플래그로 사용할 수도 있다).

 Malloc 라이브러리 내부에서 "청크 포인터" 또는 mchunkptr은 청크의 시작
주소를 가리키지 않고, 이전 청크의 마지막 워드를 가리킨다 - i.e. mchunkptr의
첫 번째 필드는 free된 이전 청크를 알지 못하는 한 유효하지 않다.

 모든 청크들의 크기는 8 바이트의 배수이므로, 청크 크기의 세 LSB들은
플래그로 사용될 수 있다. 이러한 세 개의 플래그는 다음과 같이 정의된다:
* A (0x04): 할당된 아레나 - 메인 아레나는 어플리케이션의 힙을 쓴다. 그리고
나머지 아레나들은 mmap된 힙들을 사용한다. 청크를 힙에 매핑하기 위해 어떤
경우에 속하는지 알아야 한다. 이 플래그의 비트가 0이면, 청크는 메인 아레나와
메인 힙에 속한다. 이 플래그의 비트가 1이면, 이 청크는 mmap된 메모리에
속하고 청크의 주소를 통해 힙의 위치를 계산할 수 있다.
* M (0x02): MMap된 청크 - 이 청크는 mmap 함수를 호출하여 할당되었고
힙에 속하지 않는다.
* P (0x01): 이전 청크가 사용되고 있음 - 이 플래그가 셋트이면, 이전 청크는
어플리케이션에 의해 사용 중이고, 따라서 prev_size 필드는 유효하지 않다.
단, 몇몇 청크들, 예를 들면 fastbin에 있는 (아래에서 설명) 청크들은
어플리케이션으로부터 free되었다고 해도 이 비트를 셋트한 채로 유지할 수
있다. 이 비트의 실제 의미는 이전 청크가 병합 대상으로 인식돼서는 안된다는
것이다 - 이 청크는 어플리케이션이나 malloc의 코드 맨 위에 있는 최적화
계층에 의해 "사용 중"이다.

 청크의 페이로드 영역이 malloc에서 요구하는 오버헤드를 충족시킬만큼
크다면, 청크의 최소 크기는 4 * sizeof(void *) (size_t가 void *와 같은
크기를 가지지 않는 한) 이다. 이러한 최소 크기는 플랫폼의 ABI가 추가적인
정렬을 요구한다면 더 커질 수 있다. 단, prev_size가 청크의 최소 크기를
5*sizeof(void *)로 증가시키지는 않는다. 왜냐하면 청크가 작다면
bk_nextsize 포인터가 사용되지 않을 것이고, 청크가 충분히 크다면 결국
충분한 공간이 있는 것이기 때문이다.
<pre><code>
        이미 사용 중인 청크
      [  prev_size   ] <- mchunkptr
-     [ size  ][ AMP ]
^     [              ] <- returned by malloc
|     [              ]
chunk [   payload    ]
|     [              ]
v     [              ]
-     [ size  ][ AMP ] P = 1

        free된 청크
      [  prev_size   ] <- mchunkptr
-     [ size  ][ AMP ]
^     [ fwd          ] <- returned by malloc
|     [    bck       ]
chunk [ fd_nextsize  ] -> large chunks only
|     [  bk_nextsize ] -> large chunks only
|     [  ...         ]
v     [  prev_size   ] -> same as size
-     [ size  ][ AMP ] P = 0
</code></pre>
여기서 청크가 메모리에서 서로 인접하므로, 만약 첫 번째 청크 (가장 낮은
주소를 가지는) 의 주소를 안다면, 힙에 존재하는 모든 청크를 size 정보를
이용하여 접근할 수 있다. 하지만 주소를 증가시키는 연산만을 사용해야 하고,
마지막 청크를 감지하는 것은 어려울 수 있다.

 할당된 힙들은 항상 2의 제곱의 주소로 정렬된다. 즉, 청크가 할당된 힙에
존재할 때 (i.e. A 비트가 셋트일 때) 그 힙을 위한 heap_info의 주소는
청크의 주소를 기반으로 계산될 수 있다.
<pre><code>
mchunkptr -> 0x7ffa6b3414123dc0
             |     |    |max   |
             0x7ffa6b3414000000 -> heap_info *
</code></pre>

# References
[1] CarlosODonell et al., MallocInternals,
https://sourceware.org/glibc/wiki/MallocInternals, 2022

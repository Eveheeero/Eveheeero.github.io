---
layout: post
title: TDES Differential Cryptanalysis
---

> 차등 암호분석 개요
>
> TDES의 Sbox 차이 분석
>
> 입출력값의 차이를 선택하는 방법
>
> TDES의 차등 암호분석
>
> 보조키 비트 복구 알고리즘
>
> 키 비트를 모두 복구하는 방법
>
> 블록암호 설계원칙

# 차등 암호분석 개요
 차등 암호분석(Differential Cryptanalysis)은 DES를 분석하기 위해
개발되었으므로, DES 범주 내에서 검토해보자. Sbox를 제외한 DES의 다른 모든
요소는 선형이라는 것에 주목하자. 물론, Biham과 Shamir가 차등 암호분석을
여러 버전의 DES에 적용시켰을 때 원래 버전을 제외하고는 모두 보안성이
약화되었다는 것을 확인하였다는 점에서 선형 부분이 보안성에 기여하는 부분이
없다고 할 수 없다. 그러나, 선형 부분은 상대적으로 쉬운 부분에 속하기 때문에
단 하나 뿐인 비선형 요소에 집중하는 것이다.

 여기서는 DES가 아닌 [1]에 제시된 TDES에 차등 암호분석을 적용할 것이지만 기본적인 동작
원리는 같다. 즉, 단일 Sbox에 대한 공격을 여러 Sbox에 대한 공격으로
확장시키고, 이를 다시 여러 회전에 대한 공격으로 확장시키는 것이다. 이는 어려운
문제로 보이지만 입력과 출력의 차이에 초점을 맞춘다면, 일부 Sbox를
"활성화"시키고 다른 것은 "비활성화"시킬 수 있다. 따라서 그 공격을 단일
회전에 대한 공격으로 확장할 수 있다. 그리고 이를 다시 다수의 회전에 대한
공격으로 확장하기 위해 현재 회전의 출력 차이가 다음 회전에 유용한 형식이
되도록 현재 회전의 입력 차이를 선택해야할 것이다. 이는 간단한 문제는 아니며
각 회전에서 일어나는 선형 혼합뿐 아니라 Sbox 고유 특성에도 의존한다.
 이러한 차등 암호분석의 결과가 꼭 100%의 확률로 확정적일 필요는 없다. 즉,
어떤 결과가 만들어질 확률이 의미 있는 크기라면, 키를 성공적으로 찾아내는 데
있어 효과적으로 활용될 수 있는 확률적인 공격기법을 개발할 수 있다.

# TDES의 Sbox 차이 분석
 그럼 TDES의 유일한 비선형 요소인 Sbox의 입출력 차이를 살펴보자. Sbox를
다음과 같이 분석하면 유용한 입력 차이를 얻을 수 있다. 각각의 가능한 입력 X에
대해
X = X1 &oplus; X2 (단, &oplus;는 XOR 연산)
를 만족하는 모든 쌍 (X1, X2)를 찾고
해당하는 출력 차이 Y = Y1 &oplus; Y2를 계산한다. 여기서
Y1 = Sbox(X1), Y2 = Sbox(X2)이다. 이 결과를 표로 정리하면 가장 편향된 출력
차이를 만들어내는 입력 값을 찾을 수 있다. 다음 표는 TDES의 Sbox 차이를 분석한
결과이다.

<pre><code>
<strong>64</strong> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 06 02 02 02 00 04 06 02 06 08 08 02 08 06 00
00 02 00 02 00 00 00 04 06 08 02 16 12 00 00 04
04 04 06 08 02 04 04 04 08 10 00 00 00 02 04 04
04 02 04 08 00 06 00 02 02 00 06 04 08 04 02 02
02 12 08 02 06 04 14 00 02 00 06 12 02 02 04 02
02 00 10 00 06 00 00 04 00 02 04 08 06 04 04 06
06 08 00 04 02 06 06 04 02 00 04 02 00 06 06 06
06 06 02 08 12 00 04 02 00 00 <strong>48</strong> 00 04 00 00 00
00 04 00 00 04 04 00 00 00 02 02 06 02 06 02 00
00 04 08 02 06 08 00 02 08 06 00 00 08 02 06 08
08 00 04 08 00 02 12 04 06 00 04 04 04 08 02 10
10 00 04 08 02 04 00 00 04 08 04 02 00 02 00 06
06 06 04 02 00 02 02 08 04 02 06 12 08 00 02 08
08 14 10 02 02 06 00 00 02 02 04 02 10 00 00 02
02 00 04 06 04 04 08 08 00 04 06 06 06 04 02 00
00 04 00 02 08 06 00 00 04 08 06 08 06 00 12 00
00 00 04 00 12 04 02 02 04 06 04 04 02 04 08 08
08 00 04 06 04 04 02 02 04 02 02 02 08 02 04 10
10 00 08 00 04 04 10 00 04 00 02 08 14 00 04 04
04 02 04 04 04 04 00 08 04 12 02 02 10 04 04 02
02 02 04 02 00 00 06 00 02 04 04 10 02 02 04 06
06 04 06 02 04 08 08 04 14 02 02 04 00 02 02 04
04 02 04 04 04 04 04 00 06 00 04 10 10 06 08 02
02 04 00 00 02 02 04 06 02 02 00 02 10 08 00 04
04 08 12 00 02 00 06 00 08 00 12 00 04 02 04 04
04 02 04 02 06 04 08 00 04 08 04 04 04 06 04 02
02 02 02 08 02 02 02 00 08 04 10 00 10 04 04 00
00 02 04 04 00 04 08 14 00 04 04 02 00 08 04 04
04 02 02 04 12 04 02 10 04 02 00 02 04 00 02 00
00 06 10 02 04 04 06 04 02 04 04 08 06 02 12 02
02 10 04 00 02 06 04 00 06 02 04 02 04 04 02 00
00 04 00 06 06 08 10 10 00 00 02 04 04 06 02 02
02 02 02 00 02 00 04 06 08 02 00 08 12 02 08 00
00 08 02 02 00 10 00 02 06 02 00 02 12 04 10 02
02 02 08 02 00 00 06 02 04 12 02 00 02 02 04 06
06 04 08 10 04 06 02 06 04 08 10 00 04 00 12 02
02 04 02 00 00 02 00 00 06 04 06 06 00 06 08 02
02 04 12 02 00 06 14 00 14 08 04 00 00 00 00 02
02 00 02 04 04 08 04 04 02 08 02 00 02 10 00 02
02 04 14 04 02 00 04 06 00 00 00 04 06 08 02 04
04 04 06 12 02 04 08 00 04 12 06 06 06 08 02 04
04 04 00 02 04 04 02 00 00 04 00 10 02 02 06 02
02 00 02 12 04 00 02 02 08 10 02 00 06 02 00 12
12 02 02 04 02 04 00 02 08 10 06 04 02 06 04 06
06 10 00 04 08 12 02 04 00 00 00 04 02 02 06 00
00 00 08 00 02 06 04 04 04 08 02 06 10 02 14 06
06 12 00 02 00 02 00 04 02 00 02 08 04 02 06 08
08 02 04 02 10 00 00 02 14 04 02 04 04 06 02 00
00 00 06 02 00 00 04 08 08 08 02 04 06 00 04 06
06 06 06 06 12 06 04 04 08 02 04 04 00 02 00 04
04 02 00 02 02 08 02 02 02 06 04 06 08 02 06 00
00 06 02 06 16 00 10 04 00 08 02 00 00 00 02 04
04 04 04 06 04 02 00 04 04 04 10 08 04 04 04 00
00 06 00 00 06 08 00 00 02 00 06 10 08 10 00 04
04 04 06 04 04 00 06 04 06 02 06 08 08 00 02 02
02 00 04 04 08 04 04 02 00 06 02 12 00 00 00 04
04 10 08 00 02 02 06 06 06 00 00 06 08 00 02 04
04 08 00 06 02 10 06 02 06 04 00 06 00 08 00 04
04 02 08 06 08 12 00 00 00 08 02 08 02 02 02 06
06 04 02 02 02 06 06 08 02 06 00 06 08 04 18 00
00 00 04 06 08 00 04 02 00 00 04 06 00 04 04 02
02 00 08 04 04 10 00 06 04 04 06 08 00 00 02 00
00 00 00 08 06 02 10 04 06 00 04 04 06 04 08 04
</code></pre>

# 입출력값의 차이를 선택하는 방법
 앞서 얻은 Sbox 분석 결과는 각각의 입력 차이에 대한 출력 차이가 편향된 정도의
분포를 나타낸다. 이 숫자가 클수록 편향의 정도가 큰 것이고, 분석을 위해서는 클수록
좋다. 다시 분석 결과를 살펴보면 편향의 정도가 가장 큰 경우가 64이고, 그 다음으로
큰 경우가 48임을 알 수 있다. 그리고 세 번째로 큰 값은 16으로 앞의 두 값에 비해
상당히 작다. 그럼 64, 48을 가지는 입출력 차이를 살펴보자.

<pre><code>
	64(probability 1): X1 &oplus; X2 = 000000 &rArr; SR(X1) &oplus; SR(X2) = 0000    --- (1)
	48(probability 0.75): X1 &oplus; X2 = 001000 &rArr; SR(X1) &oplus; SR(X2) = 0010 --- (2)

	단, SR()은 오른쪽 Sbox 연산
</code></pre>

위 결과는 (1)이 항상 성립하고, (2)는 75% 확률로 성립한다는 것을 의미한다.
(1)이 꼭 오른쪽 Sbox에서만 성립하는 것은 아니며, 그렇기 때문에 왼쪽 Sbox에도
적용시킬 수 있다. 이러한 (1)과 (2)는 각각 Sbox의 "비활성화"와 "활성화"된
Sbox에서 상당한 확률로 성립하는 입출력 차이라는 점에서 중요하다.

# TDES의 차등 암호분석
 차등 암호분석은 선택된 평문 공격이다. 어떤 평문을 선택해야 하는지는 (2)를 통해
알 수 있다. (2)에서 X1, X2는 각각 입력 I1, I2에 대해 E(I1), E(I2) (단, E()는
TDES 확장 연산을 수행하는 함수) 의 오른쪽 절반 비트들이다. 이때
	X1 &oplus; X2 = 001000
이므로 확장의 정의로부터
	I1 &oplus; I2 = 0010
이다. 그러므로 XOR 연산의 결과값이 0x0002인 평문 쌍을 선택해야 한다. 이러한
평문 쌍을 P, P_ 라고 하고, 각각의 왼쪽 절반 비트 집합을 L, L_, 오른쪽 절반 비트 집합을 R, R_이라고 하자. 그럼 다음 식이 성립한다.

<pre><code>
	P &oplus; P_ = (L, R) &oplus; (L_, R_) = 0x0002 --- (3)
</code></pre>

그리고 TDES의 라운드 함수를 F()라고 하고, Sbox 연산을 수행하는 함수를 S(),
확장 연산을 수행하는 함수를 E()라고 하면 다음 식이 성립한다.

<pre><code>
	F(R, K) &oplus; F(R_, K) = S(E(R) &oplus; K) &oplus; S(E(R_) &oplus; K) --- (4)

	단, K는 TDES 키
</code></pre>

여기서 확장 연산은 선형 연산이므로 X1 &oplus; X2 = 0x02인 입력 X1, X2에 대해 다음이
성립한다.

<pre><code>
	(E(X1) &oplus; K) &oplus; (E(X2) &oplus; K) = E(X1) &oplus; E(X2)
	                          = E(X1 &oplus; X2)
						  = 000000 000010 ---  (5)
</code></pre>

위 식에서
Z1 = E(X1) &oplus; K, Z2 = E(X2) &oplus; K
라고 하면
Z1 &oplus; Z2 = 000000 000010
이고, 오른쪽 절반 비트의 차이는 000010이다. Z1과 Z2의
왼쪽 절반, 오른쪽 절반 비트를 각각 ZL1과 ZL2, ZR1과 ZR2라고 하면 다음이
성립한다.

<pre><code>
	ZL1 &oplus; ZL2 = 000000 --- (6)
	ZR1 &oplus; ZR2 = 000010 --- (7)
</code></pre>

위 식에서 ZL1, ZL2는 왼쪽 Sbox, ZR1, ZR2는 오른쪽 Sbox에 대한 입력이 된다.
그리고 (1)에 의해

<pre><code>
	SL(ZL1) &oplus; SL(ZL2) = 0000 --- (8)
</code></pre>

가 항상 성립한다고 말할 수 있고, (2)에 의해

<pre><code>
	SR(ZR1) &oplus; SR(ZR2) = 0010 --- (9)
</code></pre>

가 성립할 확률이 0.75라고 말할 수 있다. 따라서 위 결과와 (4)에 의해

<pre><code>
	F(R, K) &oplus; F(R_, K) = 0000 0010 --- (10)
</code></pre>

가 성립할 확률은 0.75이 된다. 정리하면 다음과 같다.

<pre><code>
	R &oplus; R_ = 0x02 &rArr; F(R, K) &oplus; F(R_, K) = 0x02 (Prob 0.75)
</code></pre>

이로써 한 회전에 대한 식을 얻었다. 이제 이를 여러 회전에 연결시켜야 한다.
P &oplus; P_ = 0x0002
인 평문 P, P_에 대해 위 식을 여러 회전에 적용시키면 다음을 얻는다.

<pre><code>
	P &oplus; P_ = 0x0002 &rArr; (L0 &oplus; F(R0, K1)) &oplus; (L_0 &oplus; F(R_0, K1)) = 0x02 = R1 &oplus; R_1
		                L1 = R0, L_1 = R_0
			        &there4; (L1, R1) &oplus; (L_1, R_1) = 0x0202 (Prob 0.75)
	P1 &oplus; P_1 = 0x0202 &rArr; (L1 &oplus; F(R1, K2)) &oplus; (L_1 &oplus; F(R_1, K2)) = 0x00 = R2 &oplus; R_2
		                L2 = R1, L_2 = R_1
		                &there4; (L2, R2) &oplus; (L_2, R_2) = 0x0200 (Prob (0.75)^2)
	P2 &oplus; P_2 = 0x0200 &rArr; (L2 &oplus; F(R2, K3)) &oplus; (L_2 &oplus; F(R_2, K3)) = 0x02 = R3 &oplus; R_3
		                L3 = R2, L_3 = R_2
		                &there4; (L3, R3) &oplus; (L_3, R_3) = 0x0002 (Prob (0.75)^2)
	P3 &oplus; P_3 = 0x0002 &rArr; (L3 &oplus; F(R3, K4)) &oplus; (L_3 &oplus; F(R_3, K4)) = 0x02 = R4 &oplus; R_4 <br>
		                L4 = R3, L_4 = R_3 <br>
		                &there4; (L4, R4) &oplus; (L_4, R_4) = 0x0002 (Prob (0.75)^3)
	                    &there4; P4 &oplus; P_4 = C &oplus; C_ = 0x0202
</code></pre>
